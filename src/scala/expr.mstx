import scala.type
import stdlib.paths
import scala.type.reference

expr-ok(s, e, ty) :- e match
  { Lit(l) ->
      literal-ok(s, l, ty)
  | PathExpr(p) ->
      path-expr-ok(s, p, ty)
  | _ -> false // FIXME
  }.

literal-ok(s, l, ty) :- l match
  { IntLit(n) ->
      prelude-type(s, "Int", ty)
  | BoolLit(b) -> b match
      { True()  -> prelude-type(s, "Boolean", ty)
      | False() -> prelude-type(s, "Boolean", ty)
      }
  }.

path-expr-ok(s, p, ty) :- {psteps}
    path-expr-with-path-steps(p, psteps)
  , path-steps-ty-ok(s, psteps, ty).

path-steps-ty-ok(s, psteps, ty) :- psteps match
  { [] -> false
  | id:[] -> {defs, matches, visible, p, d}
      query s `LEX* `DEF as defs
    , filter defs ((name, _) where name == id) matches
    , min matches lexico(`OBJ < `LEX) visible
    , only(visible, p)
    , datum(p, d)
    , d match { (_, ty0) -> compatible-ty(ty, ty0) }
  | id:ids -> {s_obj}
      resolve-obj-scope(s, id, s_obj)
    , path-steps-ty-ok(s_obj, ids, ty)
  }.
    
