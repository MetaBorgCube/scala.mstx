import stdlib.sets
import stdlib.paths

no-duplicate-types(s, name, ty) :- {tydefs, matches}
    query s `TYPE as tydefs
  , filter tydefs ((name', ty') where name' == name) matches
  , singleton(matches).

type-decl(s_mod, s, name, ty) :- {s_ty, typ}
  new s_ty -> (name, typ)

  , s_mod -[ `TYPE ]-> s_ty
  , no-duplicate-types(s_mod, ty, typ)

  , type-ok(s, ty, typ).

type-ok(s, t, ty) :- t match
  // { FunTy(arg_t, ret_t) -> arg_t match
  //     { IFT2FAT(arg_it) -> {arg_ty, ret_ty}
  //         annot-type-ok(s, arg_it, arg_ty)
  //       , type-ok(s, ret_t, ret_ty)
  //       , ty == FUNTY(arg_ty, ret_ty)
  //     }
  { IF2TY(t) -> annot-type-ok(s, t, ty) }.

predef-type-ok(s, tyname, ty) :- {tys, ps, p, n}
  query s `B*(`P`B*)*`PREDEF`TYPE as tys
  , filter tys ((name, _) where name == Id(tyname)) ps
  , only(ps, p)
  , datum(p, (n, ty)).
  
annot-type-ok(s, annot_t, ty) :- annot_t match
  { ST2AT(id, annot_opt) -> {types, matches, visible, p, d}
      query s (`B*(`P`B*)*(`I|`W)?`TYPE) as types
    , filter types ((name, _) where name == id) matches
    , min matches scala visible
    , only(visible, p)
    , datum(p, d)
    , d match { (_, ty0) -> ty == ty0 }
  }.

// A type `ty0` is compatible with any 0-argument method that returns `ty`
compatible-ty(ty0, ty) :- // {ty_unpack}
   ty0 == ty.
   // unpack-0ary-meth(ty0, ty).

unpack-0ary-meth(ty0, ty1) :- ty0 match
  { METH([], ty00) -> unpack-0ary-meth(ty00, ty1)
  | _ -> ty0 == ty1 }.
