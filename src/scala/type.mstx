import stdlib.sets
import stdlib.paths

import scala.type.reference
import scala.paths

class-instance(cls, ty) :- cls match
  { CLASS(s_cls) -> ty == OBJECT(s_cls)
  }.

no-duplicate-types(s, name, ty) :- {tydefs, matches}
    query s `TYPE as tydefs
  , filter tydefs ((name', ty') where name' == name) matches
  , singleton(matches).

type-decl(s_mod, s, name, ty) :- {s_ty, typ}
  new s_ty -> (name, typ)

  , s_mod -[ `TYPE ]-> s_ty
  , no-duplicate-types(s_mod, name, typ)

  , type-ok(s, ty, typ).

type-ok(s, t, ty) :- t match
  // { FunTy(arg_t, ret_t) -> arg_t match
  //     { IFT2FAT(arg_it) -> {arg_ty, ret_ty}
  //         annot-type-ok(s, arg_it, arg_ty)
  //       , type-ok(s, ret_t, ret_ty)
  //       , ty == FUNTY(arg_ty, ret_ty)
  //     }
  { IF2TY(t) -> annot-type-ok(s, t, ty) }.

type-id-ok(s, id, ty) :- {types, matches, visible, sd}
  query s (`B*(`P`B*)*(`I|`W)?(`TYPE|`VAL)) as types
  , filter types ((name, _) where name == id) matches
  , min matches scala visible
  // the scala spec states that ambiguity is okay, as long as
  // they all resolve in the end to the same declaration
  , inhabited(visible)
  , same-target(visible, sd)
  , sd -> (id, ty).

path-type-ok(s, p, ty) :- p match
  { UnqualifiedId(id)   -> type-id-ok(s, id, ty)
  | QualifiedId(p', id) -> {s_obj, ps, op, s_d}
      resolve-path(s, p', s_obj)
      , resolve-local-decl(s_obj, id, ps)
      , only(ps, op)
      , tgt(op, s_d)
      , s_d -> (id, ty)
  }.

predef-type-ok(s, tyname, ty) :- {tys, ps, p, n}
  query s `B*(`P`B*)*`PREDEF`TYPE as tys
  , filter tys ((name, _) where name == tyname) ps
  , only(ps, p)
  , datum(p, (n, ty)).
  
predef-type-instance(s, tyname, ty) :- {cls}
  predef-type-ok(s, tyname, cls)
  , class-instance(cls, ty).

annot-type-ok(s, annot_t, ty) :- annot_t match
  { ST2AT(id, annot_opt) -> path-type-ok(s, id, ty) }.

// A type `ty0` is compatible with any 0-argument method that returns `ty`
compatible-ty(ty0, ty) :- // {ty_unpack}
   ty0 == ty.
   // unpack-0ary-meth(ty0, ty).

unpack-0ary-meth(ty0, ty1) :- ty0 match
  { METH([], ty00) -> unpack-0ary-meth(ty00, ty1)
  | _ -> ty0 == ty1 }.

is-value-type(ty) :- ty match
  { OBJECT(_) -> true
  | _ -> false
  }.
