import stdlib.paths
import stdlib.bools
import stdlib.maybe

import scala.type.reference
import scala.paths

iimport-ok(s, s', i) :- i match
  { ImportExpr(stable_id, grp) -> 
      iimports-stable-id(s, s', stable_id, grp)
  }.

// s is where we will create the import edge
// s' is where we are resolving into
iimports-stable-id(s, s', stable_id, grp) :- {psteps}
    path-to-list(stable_id, psteps)
  , psteps match { id:ids -> // paths have length at least one
      {s_obj}
        resolve-object(s', id, s_obj)
      , iimports-path-steps(s, s_obj, ids, grp)
    }.

iimports-path-steps(s, s_obj, psteps, grp) :- psteps match
  { [] ->
      iimports-selector(s, s_obj, grp)
  | id:ids -> {s_obj'}
      resolve-object(s_obj, id, s_obj')
    , iimports-path-steps(s, s_obj', ids, grp)
  }.

iimports-selector(s, s_obj, grp) :- grp match
  { IId(id) -> {lbl, s_imp, decls}
      resolve-local-decl(s_obj, id, decls)
      , new s_imp
      , s -[ `I ]-> s_imp
      , copy-decls(s_imp, decls)
  | IWild() ->
      s -[ `W ]-> s_obj
  | IReveal(sels) -> {s_imp, decls}
      new s_imp
      , s -[ `I ]-> s_imp
      , local-decls(s_obj, decls)
      , imports-list(s_imp, decls, sels)
      , renamings(s_imp, decls, sels)
  | IHide(sels) -> {s_imp, decls}
      new s_imp
      , s -[ `I ]-> s_imp
      , local-decls(s_obj, decls)
      , imports-everything-but(s_imp, decls, sels)
      , renamings(s_imp, decls, sels)
  }.

imports-list(s, ps, sels) :-
  every ps (p -> {l, sd, sel, id, ty}
      last(p, l, sd)
      , sd -> (id, ty)
      , selects(id, sels, sel)
      , sel match { True() -> copy-decl(s, l, sd) | False() -> true }).

imports-everything-but(s, ps, sels) :-
  every ps (p -> {l, sd, sel, id, ty}
      last(p, l, sd)
      , sd -> (id, ty)
      , hides(id, sels, sel)
      , sel match { False() -> copy-decl(s, l, sd) | True() -> true }).

renamings(s, ps, sels) :-
  every ps (p -> {l, sd, id, to, ty}
      last(p, l, sd)
      , sd -> (id, ty)
      , renames(id, sels, to)
      , to match
        { Nothing() -> true
        | Just(id') -> {sd'} new sd' -> (id', ty), copy-decl(s, l, sd') }).

// assumes something is revealed unless hidden
hides(id, sels, sel) :- sels match
  { []   -> is-false(sel)
  | s:xs -> {s1, s2}
      pattern-hides(id, s, s1)
      , hides(id, xs, s2)
      , or(s1, s2, sel)
  }.

// assumes something is hidden unless explicitly selected by sels
selects(id, sels, sel) :- sels match
  { []   -> is-false(sel)
  | s:xs -> {s1, s2}
      pattern-selects(id, s, s1)
      , selects(id, xs, s2)
      , or(s1, s2, sel)
  }.

renames(id, sels, id') :- sels match
  { []   -> id' == Nothing()
  | s:xs -> {s1, s2, id1, id2}
      pattern-renames(id, s, id1)
      , renames(id, xs, id2)
      , maybe-or(id1, id2, id')
  }.

pattern-selects(id, sel, b) :- sel match
  { Select(x) where x == id -> is-true(b)
  | _                       -> is-false(b)
  }.

pattern-hides(id, sel, b) :- sel match
  { Hide(x) where x == id -> is-true(b)
  | _                     -> is-false(b)
  }.

pattern-renames(id, sel, id') :- sel match
  { Rename(x, y) where x == id -> id' == Just(y)
  | _                          -> is-nothing(id')
  }.

copy-decls(s, decls) :-
  every decls (p -> {l, d} last(p, l, d) , copy-decl(s, l, d)).

copy-decl(s, l, d) :- l match
  { `VAL -> s -[ `VAL ]-> d
  | `TYPE -> s -[ `TYPE ]-> d
  }.
