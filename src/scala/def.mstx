import stdlib.lists
import stdlib.sets

import scala.templates
import scala.expr
import scala.type

// Scala allows overloaded defs, but not duplicate defs
no-duplicate-defs(s, name, ty) :- {defs, matches}
    query s `VAL as defs
  , filter defs ((name', ty') where name' == name, ty' == ty) matches
  , singleton(matches).

def-ok(s_mod, s, def) :- def match
  { TD2DF(typedef) -> type-def-ok(s_mod, s, typedef)
  | VD2DF(valdef)  -> value-def-ok(s_mod, s, valdef)
  | TM2DF(tmpldef) -> template-def-ok(s_mod, s, tmpldef)
  | FD2DF(fundef)  -> function-def-ok(s_mod, s, fundef)
  }.
  
value-def-ok(s_mod, s, valdef) :- valdef match
  { ValDef(name, ty, e) -> {s_val, cls, typ}
      new s_val -> (name, typ)
      , s_mod -[ `VAL ]-> s_val 
      , type-ok(s, ty, cls)
      , expr-ok(s, e, typ)
      , class-instance(cls, typ) 
  }.

template-def-ok(s_mod, s, def) :- def match
  { OD2TM(od) -> object-def-ok(s_mod, s, od)
  }.

type-def-ok(s_mod, s, tydef) :- tydef match
  { TypeDef(name, decl) -> type-decl(s_mod, s, name, decl)
  }.

function-def-ok(s_mod, s, fundef) :- fundef match
  // function def without generics and with type annotations
  { FunDef(FS(name, None(), params), Some(retty), body) -> {s_fun, tys, ty}
      new s_fun -> (name, METHOD(tys, ty))
      , s_mod -[ `VAL ]-> s_fun
      , no-duplicate-defs(s_mod, name, ty)

      , parameters-ok(s, s_fun, params, tys)
      , type-ok(s, retty, ty)

  // type unannotated or generic function defs not supported
  | _ -> false
  }.

parameters-ok(s, s_fun, params, tys) :- params match
  { []   -> tys == []
  | p:ps -> {ty, tys'} 
     param-ok(s, s_fun, p, ty)
     , parameters-ok(s, s_fun, ps, tys')
     , tys == ty:tys'
  }.

param-ok(s, s_fun, param, ty) :- param match
  // type annotated parameters
  { Param(id, Some(t)) -> {s_param}
       type-ok(s, t, ty)
       , new s_param -> (id, ty)
       , s_fun -[ `VAL ]-> s_param

  // unannotated parameters not supported
  | Param(_, None()) -> false
  }.
