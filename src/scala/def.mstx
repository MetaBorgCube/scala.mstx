import scala.type
import scala.expr

def-ok(s, def) :- def match
  { FD2DF(fs) -> fs match
      { FunSig(sig, rt, expr) -> rt match
          { NoTypeAnnot() -> {rty}
              fun-ok(s, sig, expr, rty)
          | TA(t) -> {rty}
              type-ok(s, t, rty)
            , fun-ok(s, sig, expr, rty)
          }
      }
  }.

fun-ok(s, sig, expr, rty) :- sig match
  { FS(fname, ftpclause, pclauses) -> ftpclause match
      { NoFunTypeParamClause() ->
          pclauses-ok(s, s, fname, pclauses, [], expr, rty)
      | _ -> false // FIXME
      }
  }.

pclauses-ok(s, s_f, fname, pclauses, param_tys, expr, rty) :- pclauses match
  { [] -> {t, s_def}
      expr-ok(s_f, expr, rty)
    , new s_def -> METH(param_tys, rty) // FIXME: param_tys should be reversed first
    , s -[ `DEF ]-> s_def
  | pclause:pclauses -> pclause match
      { ParamClause(params) -> {s_f_inner, tys}
          new s_f_inner
        , s_f_inner -[ `LEX ]-> s_f
        , params-ok(s_f_inner, params, tys)
        , pclauses-ok(s, s_f_inner, fname, pclauses, tys:param_tys, expr, rty)
      }
  }.

params-ok(s, params, tys) :- params match
  { [] ->
      tys == []
  | param:params -> param match
      { Param(id, t_opt) -> t_opt match
          { NoParamTypeAnnot() ->
              false //
          | PTA2P(t) -> {ty, tys_tail, s_param}
              type-ok(s, t, ty)
            , new s_param -> (id, ty)
            , s -[ `VAR ]-> s_param
            , params-ok(s, params, tys_tail)
            , tys == ty:tys_tail
          }
      }
  }.


      
